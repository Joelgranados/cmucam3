#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include "slip.h"
#include "csmsg.h"

/** SLIP Packaging **/
/** Taken from: http://tools.ietf.org/html/rfc1055 **/

/**
 * Starts a slip packet
 */
void init_packet( void ) {
    /* send an initial END character to flush out any data that may
    * have accumulated in the receiver due to line noise
    */
    putchar(END);
}

/**
 * Finishes a slip packet
 */
void finish_packet( void ) {
    putchar(END);
}	

/**
 * Uses putchar() to put a byt through
 * the serial link. It will slip encode the char
 * if necessary.
 * @param c char to be escaped and sent
 */
void put_slip_char( char c ) {
    switch(c) {
        /* if it's the same code as an END character, we send a
        * special two character code so as not to make the
        * receiver think we sent an END
        */
        case END:
            putchar(ESC);
            putchar(ESC_END);
            break;

        /* if it's the same code as an ESC character,
        * we send a special two character code so as not
        * to make the receiver think we sent an ESC
        */
        case ESC:
            putchar(ESC);
            putchar(ESC_ESC);
            break;

        /* otherwise, we just send the character
        */
        default:
            putchar(c);
    }
}
/**
 * Calls put_slip_char for each character
 * in the string s
 * @param s char* string to send over through the serial link
 */
void put_slip_string( char* s ) {
	for( int i=0; i<(int)strlen(s); i++ ) {
		put_slip_char(s[i]);
	}	
}

/**
 * Puts the slip size, using the get_size_* methods.
 */
void put_slip_size(int size) {
    put_slip_char(get_size_most_repr(size));
    put_slip_char(get_size_middle_repr(size));
    put_slip_char(get_size_least_repr(size));
}

/**
 * Put an integer - turn the integer into a string, then send the size
 * and the string itself.
 */
void put_slip_integer(int number) {
    char buff[10];

    sprintf(buff, "%d", number);
    put_slip_size(strlen(buff));
    put_slip_string(buff);
}


/* SEND_PACKET: sends a packet of length "len", starting at
* location "p".
*/
void send_packet(uint_least8_t *p, int len) {

    init_packet();

    /* for each byte in the packet, send the appropriate character
    * sequence
    */
    while(len--) {
		put_slip_char(*p);
        p++;
    }

    /* tell the receiver that we're done sending the packet
    */
    finish_packet();
}


void stream_packet(char* (*_char_getter)(char*), char* msg ) {
	init_packet();
	char* pc = NULL;
	while( (pc = (*_char_getter)(msg)) != NULL ) {
		put_slip_char(*pc);
	}
	finish_packet();	
}


/* RECV_PACKET: receives a packet into the buffer located at "p".
*      If more than len bytes are received, the packet will
*      be truncated.
*      Returns the number of bytes stored in the buffer.
*/
int recv_packet(uint_least8_t* p, int max) {

    uint_least8_t c;
    int received = 0;
    bool end_rcvd = false;

    /* sit in a loop reading bytes until we put together
    * a whole packet.
    * Make sure not to copy them into the packet if we
    * run out of room.
    */
    while(1) {
        /* get a character to process
        */
//        if ( !recv_char(&c) ) {
//			return -1;
//        }
		c = getchar();
        /* handle bytestuffing if necessary
        */
        switch(c) {

            /* if it's an END character then we're done with
            * the packet
            */
            case END:
                /* a minor optimization: if there is no
                * data in the packet, ignore it. This is
                * meant to avoid bothering IP with all
                * the empty packets generated by the
                * duplicate END characters which are in
                * turn sent to try to detect line noise.
                */
                end_rcvd = true;
                if(received) {
                    return received;
                }
                else {
                    break;
                }

            /* if it's the same code as an ESC character, wait
            * and get another character and then figure out
            * what to store in the packet based on that.
            */
            case ESC:
//                if ( !recv_char(&c) ) {
//                	// this is really bad! Not sure how to recover!
//                	//printf("ERROR! stopped receiving chars in the middle of a message!");
//                	break;
//                }
				c = getchar();
                /* if "c" is not one of these two, then we
                * have a protocol violation.  The best bet
                * seems to be to leave the byte alone and
                * just stuff it into the packet
                */
                switch(c) {
                    case ESC_END:
                        c = END;
                        break;
                    case ESC_ESC:
                        c = ESC;
                        break;
                }

            /* here we fall into the default handler and let
            * it store the character for us
            */
            default:
                if(end_rcvd && received < max) {
                    p[received++] = c;
                }
        }
    }
}



